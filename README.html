<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>Unipath</title>
<meta name="author" content="Mike Orr &lt;sluggoster&#64;gmail.com&gt;" />
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="unipath">
<h1 class="title">Unipath</h1>
<h2 class="subtitle" id="an-object-oriented-approach-to-file-directory-operations">An object-oriented approach to file/directory operations</h2>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Version:</th>
<td>1.1</td></tr>
<tr class="field"><th class="docinfo-name">Home page:</th><td class="field-body"><a class="reference external" href="https://github.com/mikeorr/Unipath">https://github.com/mikeorr/Unipath</a></td>
</tr>
<tr class="field"><th class="docinfo-name">Docs:</th><td class="field-body"><a class="reference external" href="https://github.com/mikeorr/Unipath#readme">https://github.com/mikeorr/Unipath#readme</a></td>
</tr>
<tr><th class="docinfo-name">Author:</th>
<td>Mike Orr &lt;<a class="reference external" href="mailto:sluggoster&#64;gmail.com">sluggoster&#64;gmail.com</a>&gt;</td></tr>
<tr class="field"><th class="docinfo-name">License:</th><td class="field-body">MIT (<a class="reference external" href="http://opensource.org/licenses/MIT">http://opensource.org/licenses/MIT</a>)</td>
</tr>
</tbody>
</table>
<!-- To format this document as HTML:
rst2html.py README.txt README.html -->
<p><strong>Unipath</strong> is an object-oriented front end to the file/directory functions
scattered throughout several Python library modules.  It's based on Jason
Orendorff's <em>path.py</em> but focuses on user convenience rather than on strict
adherence to the underlying functions' syntax.does not adhere as strictly to the
underlying functions' syntax. Unipath is stable, well-tested, and has been used
in production since 2008. It runs on Python 2.6+ and 3.2+.</p>
<p><strong>Version 1.1</strong> is a bugfix release. It fixes a Unicode incompatibility on
Python 3 under Windows. (Or more generally, on operating systems with native
Unicode filenames.) The license is changed to MIT. It's as permissive as the
former Python license but is smaller and simpler to read.</p>
<p>Python 3.4 introduced another object-oriented path library, <tt class="docutils literal">pathlib</tt>. It's
available on PyPI as <tt class="docutils literal">pathlib2</tt> for older versions of Python. (<tt class="docutils literal">pathlib</tt> on
PyPI is a frozen earlier version.) Unipath is now in maintenance mode.  The
author is exploring a subclass of pathlib(2) adding some of Unipath's features.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id11">Introduction</a></li>
<li><a class="reference internal" href="#installation-and-testing" id="id12">Installation and testing</a></li>
<li><a class="reference internal" href="#path-and-abstractpath-objects" id="id13">Path and AbstractPath objects</a><ul>
<li><a class="reference internal" href="#constructor" id="id14">Constructor</a></li>
<li><a class="reference internal" href="#normalization" id="id15">Normalization</a></li>
<li><a class="reference internal" href="#properties" id="id16">Properties</a></li>
<li><a class="reference internal" href="#methods" id="id17">Methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#path-objects-only" id="id18">Path objects only</a><ul>
<li><a class="reference internal" href="#note-on-arguments" id="id19">Note on arguments</a></li>
<li><a class="reference internal" href="#current-directory" id="id20">Current directory</a></li>
<li><a class="reference internal" href="#calculating-paths" id="id21">Calculating paths</a></li>
<li><a class="reference internal" href="#listing-directories" id="id22">Listing directories</a></li>
<li><a class="reference internal" href="#file-attributes-and-permissions" id="id23">File attributes and permissions</a></li>
<li><a class="reference internal" href="#modifying-paths" id="id24">Modifying paths</a><ul>
<li><a class="reference internal" href="#creating-renaming-removing" id="id25">Creating/renaming/removing</a></li>
<li><a class="reference internal" href="#symbolic-and-hard-links" id="id26">Symbolic and hard links</a></li>
</ul>
</li>
<li><a class="reference internal" href="#high-level-operations" id="id27">High-level operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tools" id="id28">Tools</a><ul>
<li><a class="reference internal" href="#dict2dir" id="id29">dict2dir</a></li>
</ul>
</li>
<li><a class="reference internal" href="#acknowledgments" id="id30">Acknowledgments</a></li>
<li><a class="reference internal" href="#comparision-with-os-os-path-shutil-and-path-py" id="id31">Comparision with os/os.path/shutil and path.py</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id11">Introduction</a></h1>
<p>The <tt class="docutils literal">Path</tt> class encapsulates the file/directory operations in Python's
<tt class="docutils literal">os</tt>, <tt class="docutils literal">os.path</tt>, and <tt class="docutils literal">shutil</tt> modules. (Non-filesystem operations are in
the <tt class="docutils literal">AbstractPath</tt> superclass, but users can ignore this.)</p>
<p>The API has been streamlined to focus on what the application developer wants
to do rather than on the lowest-level operations; e.g., <tt class="docutils literal">.mkdir()</tt> succeeds
silently if the directory already exists, and <tt class="docutils literal">.rmtree()</tt> doesn't barf if the
target is a file or doesn't exist.  This allows the developer to write simple
calls that &quot;just work&quot; rather than entire if-stanzas to handle low-level
details s/he doesn't care about.  This makes applications more self-documenting
and less cluttered.</p>
<p>Convenience methods:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">.read_file</tt> and <tt class="docutils literal">.write_file</tt> encapsulate the open/read/close pattern.</li>
<li><tt class="docutils literal">.needs_update(others)</tt> tells whether the path needs updating; i.e.,
if it doesn't exist or is older than any of the other paths.</li>
<li><tt class="docutils literal">.ancestor(N)</tt> returns the Nth parent directory, useful for joining paths.</li>
<li><tt class="docutils literal"><span class="pre">.child(\*components)</span></tt> is a &quot;safe&quot; version of join.</li>
<li><tt class="docutils literal">.split_root()</tt> handles slash/drive/UNC absolute paths in a uniform way.</li>
</ul>
</blockquote>
<p>Sample usage for pathname manipulation:</p>
<pre class="literal-block">
&gt;&gt;&gt; from unipath import Path
&gt;&gt;&gt; p = Path(&quot;/usr/lib/python2.5/gopherlib.py&quot;)
&gt;&gt;&gt; p.parent
Path(&quot;/usr/lib/python2.5&quot;)
&gt;&gt;&gt; p.name
Path(&quot;gopherlib.py&quot;)
&gt;&gt;&gt; p.ext
'.py'
&gt;&gt;&gt; p.stem
Path('gopherlib')
&gt;&gt;&gt; q = Path(p.parent, p.stem + p.ext)
&gt;&gt;&gt; q
Path('/usr/lib/python2.5/gopherlib.py')
&gt;&gt;&gt; q == p
True
</pre>
<p>Sample usage for filesystem access:</p>
<pre class="literal-block">
&gt;&gt;&gt; import tempfile
&gt;&gt;&gt; from unipath import Path
&gt;&gt;&gt; d = Path(tempfile.mkdtemp())
&gt;&gt;&gt; d.isdir()
True
&gt;&gt;&gt; p = Path(d, &quot;sample.txt&quot;)
&gt;&gt;&gt; p.exists()
False
&gt;&gt;&gt; p.write_file(&quot;The king is a fink!&quot;)
&gt;&gt;&gt; p.exists()
True
&gt;&gt;&gt; print(p.read_file())
The king is a fink!
&gt;&gt;&gt; d.rmtree()
&gt;&gt;&gt; p.exists()
False
</pre>
<p>Path objects subclass <tt class="docutils literal">str</tt> (Python 2 <tt class="docutils literal">unicode</tt>), so they can be passed
directly to fuctions expecting a string path. They are also immutable and can
be used as dictionary keys.</p>
<p>The name &quot;Unipath&quot; is short for &quot;universal path&quot;. It was originally intended to
unify the competing path APIs as of PEP 334. When the PEP was rejected, Unipath
added some convenience APIs.  The code is implemented in layers, with
filesystem-dependent code in the <tt class="docutils literal">Path</tt> class and filesystem-independent code
in its <tt class="docutils literal">AbstractPath</tt> superclass.</p>
</div>
<div class="section" id="installation-and-testing">
<h1><a class="toc-backref" href="#id12">Installation and testing</a></h1>
<p>Run &quot;pip install Unipath&quot;.  Or to install the development version, check out
the source from the Git repository above and run &quot;python setup.py develop&quot;.</p>
<p>To test the library, install 'pytest' and run &quot;pytest test.py&quot;.  It also comes
with a Tox INI file.</p>
</div>
<div class="section" id="path-and-abstractpath-objects">
<h1><a class="toc-backref" href="#id13">Path and AbstractPath objects</a></h1>
<div class="section" id="constructor">
<h2><a class="toc-backref" href="#id14">Constructor</a></h2>
<p><tt class="docutils literal">Path</tt> (and <tt class="docutils literal">AbstractPath</tt>) objects can be created from a string path, or
from several string arguments which are joined together a la <tt class="docutils literal">os.path.join</tt>.
Each argument can be a string, an <tt class="docutils literal">(Abstract)Path</tt> instance, an int or long,
or a list/tuple of strings to be joined:</p>
<pre class="literal-block">
p = Path(&quot;foo/bar.py&quot;)       # A relative path
p = Path(&quot;foo&quot;, &quot;bar.py&quot;)    # Same as previous
p = Path([&quot;foo&quot;, &quot;bar.py&quot;])  # Same as previous
p = Path(&quot;/foo&quot;, &quot;bar&quot;, &quot;baz.py&quot;)       # An absolute path: /foo/bar/baz.py
p = Path(&quot;/foo&quot;, Path(&quot;bar/baz.py&quot;))    # Same as previous
p = Path(&quot;/foo&quot;, [&quot;&quot;, &quot;bar&quot;, &quot;baz.py&quot;]) # Embedded Path.components() result
p = Path(&quot;record&quot;, 123)      # Same as Path(&quot;record/123&quot;)

p = Path(&quot;&quot;)     # An empty path
p = Path()       # Same as Path(os.curdir)
</pre>
<p>To get the actual current directory, use <tt class="docutils literal">Path.cwd()</tt>.  (This doesn't work
with <tt class="docutils literal">AbstractPath</tt>, of course.</p>
<p>Adding two paths results in a concatenated path.  The other string methods
return strings, so you'll have to wrap them in <tt class="docutils literal">Path</tt> to make them paths
again. A future version will probably override these methods to return paths.
Multiplying a path returns a string, as if you'd ever want to do that.</p>
</div>
<div class="section" id="normalization">
<h2><a class="toc-backref" href="#id15">Normalization</a></h2>
<p>The new path is normalized to clean up redundant &quot;..&quot; and &quot;.&quot; in the
middle, double slashes, wrong-direction slashes, etc.  On
case-insensitive filesystems it also converts uppercase to lowercase.
This is all done via <tt class="docutils literal">os.path.normpath()</tt>.  Here are some examples
of normalizations:</p>
<pre class="literal-block">
a//b  =&gt; a/b
a/../b =&gt; b
a/./b =&gt; a/b

a/b =&gt; a\\b            # On NT.
a\\b.JPG =&gt; a\\b.jpg   # On NT.
</pre>
<p>If the actual filesystem path contains symbolic links, normalizing &quot;..&quot; goes to
the parent of the symbolic link rather than to the parent of the linked-to
file.  For this reason, and because there may be other cases where normalizing
produces the wrong path, you can disable automatic normalization by setting the
<tt class="docutils literal">.auto_norm</tt> class attribute to false.  I'm not sure whether Unipath should
normalize by default, so if you care one way or the other you should explicitly
set it at the beginning of your application.  You can override the auto_norm
setting by passing &quot;norm=True&quot; or &quot;norm=False&quot; as a keyword argument to the
constructor.  You can also call <tt class="docutils literal">.norm()</tt> anytime to manually normalize the
path.</p>
</div>
<div class="section" id="properties">
<h2><a class="toc-backref" href="#id16">Properties</a></h2>
<p>Path objects have the following properties:</p>
<dl class="docutils">
<dt>.parent</dt>
<dd>The path without the final component.</dd>
<dt>.name</dt>
<dd>The final component only.</dd>
<dt>.ext</dt>
<dd>The last part of the final component beginning with a dot (e.g., &quot;.gz&quot;), or
&quot;&quot; if there is no dot.  This is also known as the extension.</dd>
<dt>.stem</dt>
<dd>The final component without the extension.</dd>
</dl>
<p>Examples are given in the first sample usage above.</p>
</div>
<div class="section" id="methods">
<h2><a class="toc-backref" href="#id17">Methods</a></h2>
<p>Path objects have the following methods:</p>
<dl class="docutils">
<dt>.ancestor(N)</dt>
<dd>Same as specifying <tt class="docutils literal">.parent</tt> N times.</dd>
<dt>.child(*components)</dt>
<dd>Join paths in a safe manner.  The child components may not contain a path
separator or be curdir or pardir (&quot;.&quot; or &quot;..&quot; on Posix).  This is to
prevent untrusted arguments from creating a path above the original path's
directory.</dd>
<dt>.components()</dt>
<dd>Return a list of directory components as strings.  The first component will
be the root (&quot;/&quot; on Posix, a Windows drive root, or a UNC share) if the
path is absolute, or &quot;&quot; if it's relative.  Calling <tt class="docutils literal">Path(components)</tt>,
<tt class="docutils literal"><span class="pre">Path(*components)</span></tt>, or <tt class="docutils literal"><span class="pre">os.path.join(*components)</span></tt> will recreate the
original path.</dd>
<dt>.expand()</dt>
<dd>Same as <tt class="docutils literal"><span class="pre">p.expand_user().expand_vars().norm()</span></tt>.  Usually this is all
you need to fix up a path read from a config file.</dd>
<dt>.expand_user()</dt>
<dd>Interpolate &quot;~&quot; and &quot;~user&quot; if the platform allows, and return a new path.</dd>
<dt>.expand_vars()</dt>
<dd>Interpolate environment variables like &quot;$BACKUPS&quot; if the platform allows,
and return a new path.</dd>
<dt>.isabsolute()</dt>
<dd>Is the path absolute?</dd>
<dt>.norm()</dt>
<dd>See Normalization above.  Same as <tt class="docutils literal">os.path.normpath</tt>.</dd>
<dt>.norm_case()</dt>
<dd>On case-insensitive platforms (Windows) convert the path to lower case.
On case-sensitive platforms (Unix) leave the path as is.  This also turns
forward slashes to backslashes on Windows.</dd>
<dt>.split_root()</dt>
<dd>Split this path at the root and return a tuple of two paths: the root and
the rest of the path.  The root is the same as the first subscript of the
<tt class="docutils literal">.components()</tt> result.  Calling <tt class="docutils literal">Path(root, rest)</tt> or
<tt class="docutils literal">os.path.join(root, rest)</tt> will produce the original path.</dd>
</dl>
<p>Examples:</p>
<pre class="literal-block">
Path(&quot;foo/bar.py&quot;).components() =&gt;
    [Path(&quot;&quot;), Path(&quot;foo&quot;), Path(&quot;bar.py&quot;)]
Path(&quot;foo/bar.py&quot;).split_root() =&gt;
    (Path(&quot;&quot;), Path(&quot;foo/bar.py&quot;))

Path(&quot;/foo/bar.py&quot;).components() =&gt;
    [Path(&quot;/&quot;), Path(&quot;foo&quot;), Path(&quot;bar.py&quot;)]
Path(&quot;/foo/bar.py&quot;).split_root() =&gt;
    (Path(&quot;/&quot;), Path(&quot;foo/bar.py&quot;))

Path(&quot;C:\\foo\\bar.py&quot;).components() =&gt;
    [&quot;Path(&quot;C:\\&quot;), Path(&quot;foo&quot;), Path(&quot;bar.py&quot;)]
Path(&quot;C:\\foo\\bar.py&quot;).split_root() =&gt;
    (&quot;Path(&quot;C:\\&quot;), Path(&quot;foo\\bar.py&quot;))

Path(&quot;\\\\UNC_SHARE\\foo\\bar.py&quot;).components() =&gt;
    [Path(&quot;\\\\UNC_SHARE&quot;), Path(&quot;foo&quot;), Path(&quot;bar.py&quot;)]
Path(&quot;\\\\UNC_SHARE\\foo\\bar.py&quot;).split_root() =&gt;
    (Path(&quot;\\\\UNC_SHARE&quot;), Path(&quot;foo\\bar.py&quot;))

Path(&quot;~/bin&quot;).expand_user() =&gt; Path(&quot;/home/guido/bin&quot;)
Path(&quot;~timbot/bin&quot;).expand_user() =&gt; Path(&quot;/home/timbot/bin&quot;)
Path(&quot;$HOME/bin&quot;).expand_vars() =&gt; Path(&quot;/home/guido/bin&quot;)
Path(&quot;~//$BACKUPS&quot;).expand() =&gt; Path(&quot;/home/guido/Backups&quot;)

Path(&quot;dir&quot;).child(&quot;subdir&quot;, &quot;file&quot;) =&gt; Path(&quot;dir/subdir/file&quot;)

Path(&quot;/foo&quot;).isabsolute() =&gt; True
Path(&quot;foo&quot;).isabsolute() =&gt; False
</pre>
<p>Note: a Windows drive-relative path like &quot;C:foo&quot; is considered absolute by
<tt class="docutils literal">.components()</tt>, <tt class="docutils literal">.isabsolute()</tt>, and <tt class="docutils literal">.split_root()</tt>, even though
Python's <tt class="docutils literal">ntpath.isabs()</tt> would return false.</p>
</div>
</div>
<div class="section" id="path-objects-only">
<h1><a class="toc-backref" href="#id18">Path objects only</a></h1>
<div class="section" id="note-on-arguments">
<h2><a class="toc-backref" href="#id19">Note on arguments</a></h2>
<p>All arguments that take paths can also take strings.</p>
</div>
<div class="section" id="current-directory">
<h2><a class="toc-backref" href="#id20">Current directory</a></h2>
<dl class="docutils">
<dt>Path.cwd()</dt>
<dd>Return the actual current directory; e.g., Path(&quot;/tmp/my_temp_dir&quot;).
This is a class method.</dd>
<dt>.chdir()</dt>
<dd>Make self the current directory.</dd>
</dl>
</div>
<div class="section" id="calculating-paths">
<h2><a class="toc-backref" href="#id21">Calculating paths</a></h2>
<dl class="docutils">
<dt>.resolve()</dt>
<dd>Return the equivalent path without any symbolic links.  This normalizes
the path as a side effect.</dd>
<dt>.absolute()</dt>
<dd>Return the absolute equivalent of self.  If the path is relative, this
prefixes the current directory; i.e., <tt class="docutils literal"><span class="pre">FSPath(FSPath.cwd(),</span> p)</tt>.</dd>
<dt>.relative()</dt>
<dd>Return an equivalent path relative to the current directory if possible.
This may return a path prefixed with many &quot;../..&quot;.  If the path is on a
different drive, this returns the original path unchanged.</dd>
<dt>.rel_path_to(other)</dt>
<dd>Return a path from self to other.  In other words, return a path for
'other' relative to self.</dd>
</dl>
</div>
<div class="section" id="listing-directories">
<h2><a class="toc-backref" href="#id22">Listing directories</a></h2>
<dl class="docutils">
<dt>.listdir(pattern=None, filter=ALL, names_only=False)</dt>
<dd><p class="first">Return the filenames in this directory.</p>
<p>'pattern' may be a glob expression like &quot;*.py&quot;.</p>
<p>'filter' may be a function that takes a <tt class="docutils literal">FSPath</tt> and returns true if it
should be included in the results.  The following standard filters are
defined in the <tt class="docutils literal">unipath</tt> module:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal">DIRS</tt>: directories only</li>
<li><tt class="docutils literal">FILES</tt>: files only</li>
<li><tt class="docutils literal">LINKS</tt>: symbolic links only</li>
<li><tt class="docutils literal">FILES_NO_LINKS</tt>: files that aren't symbolic links</li>
<li><tt class="docutils literal">DIRS_NO_LINKS</tt>: directories that aren't symbolic links</li>
<li><tt class="docutils literal">DEAD_LINKS</tt>: symbolic links that point to nonexistent files</li>
</ul>
</blockquote>
<p>This method normally returns FSPaths prefixed with 'self'.  If
'names_only' is true, it returns the raw filenames as strings without a
directory prefix (same as <tt class="docutils literal">os.listdir</tt>).</p>
<p>If both 'pattern' and 'filter' are specified, only paths that pass both are
included.  'filter' must not be specified if 'names_only' is true.</p>
<p class="last">Paths are returned in sorted order.</p>
</dd>
</dl>
<dt>.walk(pattern=None, filter=None, top_down=True)</dt>
<blockquote>
<p>Yield <tt class="docutils literal">FSPath</tt> objects for all files and directories under self,
recursing subdirectories.  Paths are yielded in sorted order.</p>
<p>'pattern' and 'filter' are the same as for <tt class="docutils literal">.listdir()</tt>.</p>
<p>If 'top_down' is true (default), yield directories before yielding
the items in them.  If false, yield the items first.</p>
</blockquote>
</div>
<div class="section" id="file-attributes-and-permissions">
<h2><a class="toc-backref" href="#id23">File attributes and permissions</a></h2>
<dl class="docutils">
<dt>.atime()</dt>
<dd>Return the path's last access time.</dd>
<dt>.ctime()</dt>
<dd>Return the path's ctime.  On Unix this returns the time the path's
permissions and ownership were last modified.  On Windows it's the path
creation time.</dd>
<dt>.exists()</dt>
<dd>Does the path exist?  For symbolic links, True if the linked-to file
exists.  On some platforms this returns False if Python does not have
permission to stat the file, even if it exists.</dd>
<dt>.isdir()</dt>
<dd>Is the path a directory?  Follows symbolic links.</dd>
<dt>.isfile()</dt>
<dd>Is the path a file?  Follows symbolic links.</dd>
<dt>.islink()</dt>
<dd>Is the path a symbolic link?</dd>
<dt>.ismount()</dt>
<dd>Is the path a mount point?  Returns true if self's parent is on a
different device than self, or if self and its parent are the same
directory.</dd>
<dt>.lexists()</dt>
<dd>Same as <tt class="docutils literal">.exists()</tt> but don't follow a final symbolic link.</dd>
<dt>.lstat()</dt>
<dd>Same as <tt class="docutils literal">.stat()</tt> but do not follow a final symbolic link.</dd>
<dt>.size()</dt>
<dd>Return the file size in bytes.</dd>
<dt>.stat()</dt>
<dd>Return a stat object to test file size, type, permissions, etc.
See <tt class="docutils literal">os.stat()</tt> for details.</dd>
<dt>.statvfs()</dt>
<dd>Return a <tt class="docutils literal">StatVFS</tt> object.  This method exists only if the platform
supports it.  See <tt class="docutils literal">os.statvfs()</tt> for details.</dd>
</dl>
</div>
<div class="section" id="modifying-paths">
<h2><a class="toc-backref" href="#id24">Modifying paths</a></h2>
<div class="section" id="creating-renaming-removing">
<h3><a class="toc-backref" href="#id25">Creating/renaming/removing</a></h3>
<dl class="docutils">
<dt>.chmod(mode)</dt>
<dd>Change the path's permissions.  'mode' is octal; e.g., 0777.</dd>
<dt>.chown(uid, gid)</dt>
<dd>Change the path's ownership to the numeric uid and gid specified.
Pass -1 if you don't want one of the IDs changed.</dd>
<dt>.mkdir(parents=False)</dt>
<dd>Create the directory, or succeed silently if it already exists.  If
'parents' is true, create any necessary ancestor directories.</dd>
<dt>.remove()</dt>
<dd>Delete the file.  Raises OSError if it's a directory.</dd>
<dt>.rename(dst, parents=False)</dt>
<dd>Rename self to 'dst' atomically.  See <tt class="docutils literal">os.rename()</tt> for additional
details.  If 'parents' is True, create any intermediate destination
directories necessary, and delete as many empty leaf source directories as
possible.</dd>
<dt>.rmdir(parents=False)</dt>
<dd>Remove the directory, or succeed silently if it's already gone.  If
'parents' is true, also remove as many empty ancestor directories as
possible.</dd>
<dt>.set_times(mtime=None, atime=None)</dt>
<dd>Set the path's modification and access times.  If 'mtime' is None, use
the current time.  If 'atime' is None or not specified, use the same time
as 'mtime'.  To set the times based on another file, see <tt class="docutils literal">.copy_stat()</tt>.</dd>
</dl>
</div>
<div class="section" id="symbolic-and-hard-links">
<h3><a class="toc-backref" href="#id26">Symbolic and hard links</a></h3>
<dl class="docutils">
<dt>.hardlink(src)</dt>
<dd>Create a hard link at 'src' pointing to self.</dd>
<dt>.write_link(target)</dt>
<dd>Create a symbolic link at self pointing to 'target'.  The link will contain
the exact string value of 'target' without checking whether that path exists
or is a even a valid path for the filesystem.</dd>
<dt>.make_relative_link_to(dst)</dt>
<dd>Make a relative symbolic link from self to dst.  Same as
<tt class="docutils literal">self.write_link(self.rel_path_to(dst))</tt>.  (New in Unipath 0.2.0.)</dd>
<dt>.read_link()</dt>
<dd>Return the path that this symbolic link points to.</dd>
</dl>
</div>
</div>
<div class="section" id="high-level-operations">
<h2><a class="toc-backref" href="#id27">High-level operations</a></h2>
<dl class="docutils">
<dt>.copy(dst, times=False, perms=False)</dt>
<dd>Copy the file to a destination.  'times' and 'perms' are same as for
<tt class="docutils literal">.copy_stat()</tt>.</dd>
<dt>.copy_stat(dst, times=True, perms=True)</dt>
<dd>Copy the access/modification times and/or the permission bits from this
path to another path.</dd>
<dt>.move(dst)</dt>
<dd>Recursively move a file or directory to another location.  This uses
.rename() if possible.</dd>
<dt>.needs_update(other_paths)</dt>
<dd>Return True if self is missing or is older than any other path.
'other_paths' can be a <tt class="docutils literal">(FS)Path</tt>, a string path, or a list/tuple
of these.  Recurses through subdirectories but compares only files.</dd>
<dt>.read_file(mode=&quot;r&quot;)</dt>
<dd>Return the file's content as a <tt class="docutils literal">str</tt> string.  This encapsulates the
open/read/close.  'mode' is the same as in Python's <tt class="docutils literal">open()</tt> function.</dd>
<dt>.rmtree(parents=False)</dt>
<dd>Recursively remove this path, no matter whether it's a file or a
directory.  Succeed silently if the path doesn't exist.  If 'parents' is
true, also try to remove as many empty ancestor directories as possible.</dd>
<dt>.write_file(content, mode=&quot;w&quot;)</dt>
<dd>Replace the file's content, creating the file if
necessary.  'mode' is the same as in Python's <tt class="docutils literal">open()</tt> function.
'content' is a <tt class="docutils literal">str</tt> string.  You'll have to encode Unicode strings
before calling this.</dd>
</dl>
</div>
</div>
<div class="section" id="tools">
<h1><a class="toc-backref" href="#id28">Tools</a></h1>
<p>The following functions are in the <tt class="docutils literal">unipath.tools</tt> module.</p>
<div class="section" id="dict2dir">
<h2><a class="toc-backref" href="#id29">dict2dir</a></h2>
<p>dict2dir(dir, dic, mode=&quot;w&quot;)  =&gt;  None</p>
<blockquote>
Create a directory that matches the dict spec.  String values are turned
into files named after the key.  Dict values are turned into
subdirectories.  'mode' specifies the mode for files.  'dir' can be an
<tt class="docutils literal">[FS]Path</tt> or a string path.</blockquote>
<p>dump_path(path, prefix=&quot;&quot;, tab=&quot;    &quot;, file=None)  =&gt;  None</p>
<blockquote>
<p>Display an ASCII tree of the path.  Files are displayed as
&quot;filename (size)&quot;.  Directories have &quot;:&quot; at the end of the line and
indentation below, like Python syntax blocks.  Symbolic links are
shown as &quot;link -&gt; target&quot;.  'prefix' is a string prefixed to every
line, normally to controll indentation.  'tab' is the indentation
added for each directory level.  'file' specifies an output file object,
or <tt class="docutils literal">None</tt> for <tt class="docutils literal">sys.stdout</tt>.</p>
<p>A future version of Unipath will have a command-line program to
dump a path.</p>
</blockquote>
</div>
</div>
<div class="section" id="acknowledgments">
<h1><a class="toc-backref" href="#id30">Acknowledgments</a></h1>
<p>Jason Orendorff wrote the original path.py.  Reinhold Birkenfeld and
Björn Lindkvist modified it for Python PEP 335. Mike Orr changed the API and
released it as Unipath.  Ricardo Duarte ported it to Python 3, changed the
tests to py.test, and added Tox support.</p>
</div>
<div class="section" id="comparision-with-os-os-path-shutil-and-path-py">
<h1><a class="toc-backref" href="#id31">Comparision with os/os.path/shutil and path.py</a></h1>
<pre class="literal-block">
p = any path, f =  file, d = directory, l = link
fsp, fsf, fsd, fsl = filesystem path (i.e., ``Path`` only)
- = not implemented
</pre>
<p>Functions are listed in the same order as the Python Library Reference, version
2.5.  (Does not reflect later changes to Python or path.py.)</p>
<pre class="literal-block">
os/os.path/shutil      path.py        Unipath           Notes
=================      ============== ==========        =======
os.path.abspath(p)     p.abspath()    p.absolute()     Return absolute path.
os.path.basename(p)    p.name         p.name
os.path.commonprefix(p)  -            -                Common prefix. [1]_
os.path.dirname(p)     p.parent       p.parent         All except the last component.
os.path.exists(p)      p.exists()     fsp.exists()     Does the path exist?
os.path.lexists(p)     p.lexists()    fsp.lexists()    Does the symbolic link exist?
os.path.expanduser(p)  p.expanduser() p.expand_user()  Expand &quot;~&quot; and &quot;~user&quot; prefix.
os.path.expandvars(p)  p.expandvars() p.expand_vars()  Expand &quot;$VAR&quot; environment variables.
os.path.getatime(p)    p.atime        fsp.atime()      Last access time.
os.path.getmtime(p)    p.mtime        fsp.mtime()      Last modify time.
os.path.getctime(p)    p.ctime        fsp.ctime()      Platform-specific &quot;ctime&quot;.
os.path.getsize(p)     p.size         fsp.size()       File size.
os.path.isabs(p)       p.isabs()      p.isabsolute     Is path absolute?
os.path.isfile(p)      p.isfile()     fsp.isfile()     Is a file?
os.path.isdir(p)       p.isdir()      fsp.isdir()      Is a directory?
os.path.islink(p)      p.islink()     fsp.islink()     Is a symbolic link?
os.path.ismount(p)     p.ismount()    fsp.ismount()    Is a mount point?
os.path.join(p, &quot;Q/R&quot;) p.joinpath(&quot;Q/R&quot;)  [FS]Path(p, &quot;Q/R&quot;)  Join paths.
                                          -or-
                                          p.child(&quot;Q&quot;, &quot;R&quot;)
os.path.normcase(p)    p.normcase()    p.norm_case()   Normalize case.
os.path.normpath(p)    p.normpath()    p.norm()        Normalize path.
os.path.realpath(p)    p.realpath()    fsp.real_path() Real path without symbolic links.
os.path.samefile(p, q) p.samefile(q)   fsp.same_file(q)  True if both paths point to the same filesystem item.
os.path.sameopenfile(d1, d2)  -          -               [Not a path operation.]
os.path.samestat(st1, st2)    -          -               [Not a path operation.]
os.path.split(p)       p.splitpath()   (p.parent, p.name) Split path at basename.
os.path.splitdrive(p)  p.splitdrive()   -                 [2]_
os.path.splitext(p)    p.splitext()     -                 [2]_
os.path.splitunc(p)    p.splitunc()     -                 [2]_
os.path.walk(p, func, args)  -          -                 [3]_

os.access(p, const)    p.access(const)  -                 [4]_
os.chdir(d)            -                fsd.chdir()       Change current directory.
os.fchdir(fd)          -                -                 [Not a path operation.]
os.getcwd()           path.getcwd()     FSPath.cwd()      Get current directory.
os.chroot(d)          d.chroot()        -                 [5]_
os.chmod(p, 0644)     p.chmod(0644)     fsp.chmod(0644)     Change mode (permission bits).
os.chown(p, uid, gid) p.chown(uid, gid) fsp.chown(uid, gid) Change ownership.
os.lchown(p, uid, gid) -                -                 [6]_
os.link(src, dst)     p.link(dst)       fsp.hardlink(dst)   Make hard link.
os.listdir(d)         -                 fsd.listdir(names_only=True)  List directory; return base filenames.
os.lstat(p)           p.lstat()         fsp.lstat()         Like stat but don't follow symbolic link.
os.mkfifo(p, 0666)    -                 -                 [Not enough of a path operation.]
os.mknod(p, ...)      -                 -                 [Not enough of a path operation.]
os.major(device)      -                 -                 [Not a path operation.]
os.minor(device)      -                 -                 [Not a path operation.]
os.makedev(...)       -                 -                 [Not a path operation.]
os.mkdir(d, 0777)     d.mkdir(0777)     fsd.mkdir(mode=0777)     Create directory.
os.makedirs(d, 0777)  d.makedirs(0777)  fsd.mkdir(True, 0777)    Create a directory and necessary parent directories.
os.pathconf(p, name)  p.pathconf(name)  -                  Return Posix path attribute.  (What the hell is this?)
os.readlink(l)        l.readlink()      fsl.read_link()      Return the path a symbolic link points to.
os.remove(f)          f.remove()        fsf.remove()       Delete file.
os.removedirs(d)      d.removedirs()    fsd.rmdir(True)    Remove empty directory and all its empty ancestors.
os.rename(src, dst)   p.rename(dst)     fsp.rename(dst)      Rename a file or directory atomically (must be on same device).
os.renames(src, dst)  p.renames(dst)    fsp.rename(dst, True) Combines os.rename, os.makedirs, and os.removedirs.
os.rmdir(d)           d.rmdir()         fsd.rmdir()        Delete empty directory.
os.stat(p)            p.stat()          fsp.stat()         Return a &quot;stat&quot; object.
os.statvfs(p)         p.statvfs()       fsp.statvfs()      Return a &quot;statvfs&quot; object.
os.symlink(src, dst)  p.symlink(dst)    fsp.write_link(link_text)   Create a symbolic link.
                                        (&quot;write_link&quot; argument order is opposite from Python's!)
os.tempnam(...)       -                 -                  [7]_
os.unlink(f)          f.unlink()        -                  Same as .remove().
os.utime(p, times)    p.utime(times)    fsp.set_times(mtime, atime)  Set access/modification times.
os.walk(...)          -                 -                  [3]_

shutil.copyfile(src, dst)  f.copyfile(dst) fsf.copy(dst, ...)  Copy file.  Unipath method is more than copyfile but less than copy2.
shutil.copyfileobj(...)   -             -                  [Not a path operation.]
shutil.copymode(src, dst) p.copymode(dst)  fsp.copy_stat(dst, ...)  Copy permission bits only.
shutil.copystat(src, dst) p.copystat(dst)  fsp.copy_stat(dst, ...)  Copy stat bits.
shutil.copy(src, dst)  f.copy(dst)      -                  High-level copy a la Unix &quot;cp&quot;.
shutil.copy2(src, dst) f.copy2(dst)     -                  High-level copy a la Unix &quot;cp -p&quot;.
shutil.copytree(...)  d.copytree(...)   fsp.copy_tree(...)   Copy directory tree.  (Not implemented in Unipath 0.1.0.)
shutil.rmtree(...)    d.rmtree(...)     fsp.rmtree(...)    Recursively delete directory tree.  (Unipath has enhancements.)
shutil.move(src, dst) p.move(dst)       fsp.move(dst)      Recursively move a file or directory, using os.rename() if possible.

A + B                 A + B             A+B                Concatenate paths.
os.path.join(A, B)    A / B             [FS]Path(A, B)     Join paths.
                                        -or-
                                        p.child(B)
-                     p.expand()        p.expand()         Combines expanduser, expandvars, normpath.
os.path.dirname(p)    p.parent          p.parent           Path without final component.
os.path.basename(p)   p.name            p.name             Final component only.
[8]_                  p.namebase        p.stem             Final component without extension.
[9]_                  p.ext             p.ext              Extension only.
os.path.splitdrive(p)[0] p.drive        -                  [2]_
-                     p.stripext()      -                  Strip final extension.
-                     p.uncshare        -                  [2]_
-                     p.splitall()      p.components()     List of path components.  (Unipath has special first element.)
-                     p.relpath()       fsp.relative()       Relative path to current directory.
-                     p.relpathto(dst)  fsp.rel_path_to(dst) Relative path to 'dst'.
-                     d.listdir()       fsd.listdir()        List directory, return paths.
-                     d.files()         fsd.listdir(filter=FILES)  List files in directory, return paths.
-                     d.dirs()          fsd.listdir(filter=DIRS)   List subdirectories, return paths.
-                     d.walk(...)       fsd.walk(...)        Recursively yield files and directories.
-                     d.walkfiles(...)  fsd.walk(filter=FILES)  Recursively yield files.
-                     d.walkdirs(...)   fsd.walk(filter=DIRS)  Recursively yield directories.
-                     p.fnmatch(pattern)  -                 True if self.name matches glob pattern.
-                     p.glob(pattern)   -                   Advanced globbing.
-                     f.open(mode)      -                   Return open file object.
-                     f.bytes()         fsf.read_file(&quot;rb&quot;)   Return file contents in binary mode.
-                     f.write_bytes()   fsf.write_file(content, &quot;wb&quot;)  Replace file contents in binary mode.
-                     f.text(...)       fsf.read_file()       Return file content.  (Encoding args not implemented yet.)
-                     f.write_text(...) fsf.write_file(content)  Replace file content.  (Not all Orendorff args supported.)
-                     f.lines(...)      -                   Return list of lines in file.
-                     f.write_lines(...)  -                 Write list of lines to file.
-                     f.read_md5()      -                   Calculate MD5 hash of file.
-                     p.owner           -                   Advanded &quot;get owner&quot; operation.
-                     p.readlinkabs()   -                   Return the path this symlink points to, converting to absolute path.
-                     p.startfile()     -                   What the hell is this?

-                     -                 p.split_root()      Unified &quot;split root&quot; method.
-                     -                 p.ancestor(N)       Same as specifying .parent N times.
-                     -                 p.child(...)        &quot;Safe&quot; way to join paths.
-                     -                 fsp.needs_update(...) True if self is missing or older than any of the other paths.
</pre>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>The Python method is too dumb; it can end a prefix in the middle of a
[The rest of this footnote has been lost.]</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Closest equivalent is <tt class="docutils literal">p.split_root()</tt> for approximate equivalent.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>More convenient alternatives exist.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td>Inconvenient constants; not used enough to port.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td>Chroot is more of an OS operation than a path operation.  Plus it's
dangerous.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td>Ownership of symbolic link doesn't matter because the OS never
consults its permission bits.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[7]</td><td><tt class="docutils literal">os.tempnam</tt> is insecure; use <tt class="docutils literal">os.tmpfile</tt> or <tt class="docutils literal">tempfile</tt> module
instead.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td><tt class="docutils literal"><span class="pre">os.path.splitext(os.path.split(p))[0]</span></tt></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[9]</td><td><tt class="docutils literal"><span class="pre">os.path.splitext(os.path.split(p))[1]</span></tt></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[10]</td><td>Closest equivalent is <tt class="docutils literal"><span class="pre">p.split_root()[0]</span></tt>.</td></tr>
</tbody>
</table>
</div>
</div>
</body>
</html>
